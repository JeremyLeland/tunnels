<title>Cell Maze Editor</title>
<link rel="stylesheet" href="../style.css">

<body>
  <canvas id="canvas" width="800px" height="800px"></canvas>
</body>

<script type="module">

  import Delaunay from '../lib/delaunay/delaunay.js';
  
  import { Line } from '../src/Line.js';
  import { Curve } from '../src/Curve.js';
  import { CellMap } from '../src/CellMap.js';
  import { Level } from '../src/Level.js';

  const width = 800, height = 800;
  const seeds = Array.from( Array( 100 ), _ => ( {
    x: Math.random() * width, 
    y: Math.random() * height
  } ) );

  const delaunay = Delaunay.from( seeds, ( e ) => e.x, ( e ) => e.y );
  const voronoi = delaunay.voronoi( [ 0, 0, width, height ] );

  const cellMap = CellMap.fromVoronoi( voronoi );

  const ctx = document.getElementById( 'canvas' ).getContext( '2d' );
  
  cellMap.cells.forEach( cell => cell.drawDebug( ctx ) );


  let mouseX = 0, mouseY = 0, mouseDown = false;
  document.addEventListener( 'mousedown', ( e ) => {
    mouseDown = true;
    removeUnderMouse();
    draw();
  } );
  document.addEventListener( 'mousemove', ( e ) => {
    mouseX = e.clientX;
    mouseY = e.clientY;

    if ( mouseDown ) {
      removeUnderMouse();
    }

    draw();
  } );
  document.addEventListener( 'mouseup', ( e ) => mouseDown = false );

  document.addEventListener( 'keypress', ( e ) => outputLevel() );

  function removeUnderMouse() {
    const cell = cellMap.cells.find( cell => cell.contains( mouseX, mouseY ) );
    if ( cell ) {
      cellMap.removeCell( cell );
      draw();
    }
  }

  draw();
  function draw() {
    ctx.clearRect( 0, 0, ctx.canvas.width, ctx.canvas.height );

    cellMap.draw( ctx );

    const subLength = 100;

    cellMap.getEdgeLoops().forEach( loop => {

      

      const sublines = Line.getOffsetLoop( loop, -10 );
      // loop.forEach( edge => sublines.push( ...edge.getSublines( subLength ) ) );

      
    //   const points = [];

    //   for ( let i = 0; i < loop.length; i ++ ) {
    //     const prev = loop.at( i - 1 );
    //     const curr = loop.at( i );

    //     const midAngle = prev.normal.angle + deltaAngle( prev.normal.angle, curr.normal.angle ) / 2;

    //     // TODO: Subdivide first before curves?

    //     const offset = -10;
    //     points.push( [
    //       curr.x1 + offset * Math.cos( midAngle ),
    //       curr.y1 + offset * Math.sin( midAngle ), 
    //     ] );
    //   }
      
    // const loopPoints = [];
    // const points = sublines.map( line => [ line.x1, line.y1 ] );
    //   Curve.getLoopThroughPoints( points ).forEach( curve => {
    //     for ( let t = 0; t <= 1; t += 0.1 ) {

    //       // TODO: This has all the overlapping line issues that we had before
    //       //       Dig up some of the old code, like for raytracing from center?
    //       //       Or take into account next and previous lines when determining offsets (to avoid overlap)

    //       const pos = curve.getPosition( t );
    //       const norm = curve.getNormal( t );
    //       const offset = 5 * Math.sin( t * 100 ); //Math.random();
    //       loopPoints.push( [ 
    //         pos[ 0 ],// + norm[ 0 ] * offset, 
    //         pos[ 1 ],// + norm[ 1 ] * offset,
    //       ] );
    //     }
    //   } );

       ctx.strokeStyle = 'orange';
      // Line.getLoopThroughPoints( loopPoints ).forEach( line => line.draw( ctx ) );
        sublines.forEach( line => line.draw( ctx ) );

    } );

    // TODO: Make this triggered separately
    // outputLevel();
  }

  function outputLevel() {
    const level = new Level();

    // cellMap.getLoops().forEach( points => {
    //   const loopPoints = [];
      
    //   Curve.getLoopThroughPoints( points ).forEach( curve => {
    //     for ( let t = 0; t <= 1; t += 0.2 ) {
    //       loopPoints.push( curve.getPosition( t ) );
    //     }
    //   } );

    //   level.loops.push( Line.getLoopThroughPoints( loopPoints ) );
    // } );

    level.cellMap = cellMap;

    console.log( level.toJson() );
  }

  function fixAngle( a ) {
    return a > Math.PI ? a - Math.PI * 2 : a < -Math.PI ? a + Math.PI * 2 : a;
  }

  function deltaAngle( a, b ) {
    return fixAngle( b - a );
  }


</script>