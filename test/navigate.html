<title>Simple Pathfinding</title>
<link rel="stylesheet" href="../style.css">

<body></body>

<script type="module">

  import { Game } from '../src/Game.js';
  import { Actor } from '../src/Actor.js';
  import { Level } from '../src/Level.js';
  import * as Pathfinding from '../src/Pathfinding.js';

  const levelJsonStr = `{
    "lines": [
      [ 100, 100, 100, 400 ],
      [ 100, 400, 400, 400 ],
      [ 400, 400, 400, 100 ],
      [ 400, 100, 100, 100 ],
      [ 200, 200, 300, 200 ],
      [ 300, 200, 300, 300 ],
      [ 300, 300, 200, 300 ],
      [ 200, 300, 200, 200 ]
    ],
    "nodes": [
      { "x": 150, "y": 150, "links": [ 3, 1 ] },
      { "x": 350, "y": 150, "links": [ 0, 2 ] },
      { "x": 350, "y": 350, "links": [ 1, 3 ] },
      { "x": 150, "y": 350, "links": [ 2, 0 ] }
    ]
  }
  `;

  /*
  "nodes": [
      { "x": 150, "y": 150, "links": [ 7, 1 ] },
      { "x": 250, "y": 150, "links": [ 0, 2 ] },
      { "x": 350, "y": 150, "links": [ 1, 3 ] },
      { "x": 350, "y": 250, "links": [ 2, 4 ] },
      { "x": 350, "y": 350, "links": [ 3, 5 ] },
      { "x": 250, "y": 350, "links": [ 4, 6 ] },
      { "x": 150, "y": 350, "links": [ 5, 7 ] },
      { "x": 150, "y": 250, "links": [ 6, 0 ] }
    ]
  */
  
  class PathfindingActor extends Actor {
    size = 10;
    speed = 0.1;
    turnSpeed = 0.008;

    target;

    node;
    path;
    waypoint;

    spawnInNode( node ) {
      this.node = node;

      // TODO: Pick random spot on random edge, 
      //       random distance between that spot and center?
      this.x = node.x;
      this.y = node.y;
    }

    update( dt ) {
      if ( this.target ) {
        if ( !this.path || this.target.node != this.path[ this.path.length - 1 ] ) {
          this.path = Pathfinding.getPath( this.node, this.target.node );
          this.waypoint = null;
        }
      }

      if ( this.waypoint && Math.hypot( this.waypoint.x - this.x, this.waypoint.y - this.y ) < this.speed * dt ) {
        this.waypoint = null;
      }

      if ( this.path && !this.waypoint ) {
        this.node = this.path.shift();

        if ( this.path.length > 0 ) {
          // this.waypoint = this.path[ 0 ];
          this.waypoint = {
            x: ( this.node.x + this.path[ 0 ].x ) / 2,
            y: ( this.node.y + this.path[ 0 ].y ) / 2,
          };
          // TODO: Nearest point on edge (instead of middle)
          // const nextEdge = this.path[ 0 ].edges.find( edge => edge.neighbor == this.node );

          // this.waypoint = {
          //   x: ( nextEdge.start.x + nextEdge.end.x ) / 2,
          //   y: ( nextEdge.start.y + nextEdge.end.y ) / 2,
          // };

          // TODO: Never mind on all this, pick better waypoints
          // if ( this.path.length == 1 ) {
          //   const toWaypoint = Math.hypot( this.waypoint.x - this.x, this.waypoint.y - this.y );
          //   const toTarget = Math.hypot( this.target.x - this.x, this.target.y - this.y );

          //   if ( toTarget < toWaypoint ) {
          //     this.node = this.waypoint;
          //     this.waypoint = null;
          //   }
          // }
        }

        if ( !this.waypoint ) {
          this.path = null;

          this.waypoint = {
            x: this.target.x,
            y: this.target.y,
          };

          // TODO: Probably shouldn't set this to null until we're done, in case target moves?
          this.target = null;
        }
      }

      if ( this.waypoint ) {
        this.goalAngle = Math.atan2( this.waypoint.y - this.y, this.waypoint.x - this.x );
        super.update( dt );     
      }
    }

    drawEntity( ctx ) {
      ctx.fillStyle = 'red';
      ctx.strokeStyle = 'white';
      ctx.fillRect( -this.size, -this.size, this.size * 2, this.size * 2 );
      ctx.strokeRect( -this.size, -this.size, this.size * 2, this.size * 2 );
    }

    draw( ctx ) {
      super.draw( ctx );
      
      ctx.beginPath();

      if ( this.target ) {
        ctx.lineTo( this.target.x, this.target.y );
      }
        
      if ( this.path ) {
        for ( let i = this.path.length - 1; i > 0; i -- ) {
          const cell = this.path[ i ];
          ctx.lineTo( cell.x, cell.y );
        }
      }
      
      if ( this.waypoint ) {
        ctx.lineTo( this.waypoint.x, this.waypoint.y );
        ctx.lineTo( this.x, this.y );
      }

      ctx.strokeStyle = 'orange';
      ctx.setLineDash( [ 4, 2 ] );
      ctx.stroke();
      ctx.setLineDash( [] );
    }
  }


  const level = Level.fromJson( levelJsonStr );
  
  const player = new PathfindingActor();
  player.spawnInNode( level.nodes[ 0 ] );

  const game = new Game();
  // game.scroll = { x: 32, y: 32 };

  game.update = ( dt ) => {
    if ( game.mouse.down ) {
      const x = game.mouse.x - game.scroll.x;
      const y = game.mouse.y - game.scroll.y;
      const node = level.closestNodeTo( x, y );
      if ( node ) {
        player.target = { x: x, y: y, node: node }
      }
    }

    player.update( dt );
  };

  game.draw = ( ctx ) => {
    level.draw( ctx );
    player.draw( ctx );
  };


</script>