<title>D3 library usage</title>
<link rel="stylesheet" href="../../style.css">

<body>
  <canvas id="canvas" width="800px" height="800px"></canvas>
</body>

<script type="module">
  import Delaunay from '../../lib/delaunay/delaunay.js';

  import { Line } from '../../src/Line.js';
  import { Cell } from '../../src/Level.js';

  const width = 800, height = 800;
  const seeds = Array.from( Array( 100 ), _ => ( {
    x: Math.random() * width, 
    y: Math.random() * height
  } ) );

  const delaunay = Delaunay.from( seeds, ( e ) => e.x, ( e ) => e.y );
  const voronoi = delaunay.voronoi( [ 0, 0, width, height ] );

  const cells = Array.from( voronoi.cellPolygons(), polygon => {
    const cell = new Cell();
    
    for ( let i = polygon.length - 1; i > 0; i -- ) {
      const current = polygon[ i ], next = polygon[ i - 1 ];
      cell.edges.push( new Line( ...current, ...next ) );
    }

    cell.updateCenter();

    return cell;
  } );

  for ( let cellIndex = 0; cellIndex < cells.length; cellIndex ++ ) {
    const neighbors = Array.from( voronoi.neighbors( cellIndex ), index => cells[ index ] );

    const cell = cells[ cellIndex ];

    cell.links = Array.from( cell.edges, edge => 
      neighbors.find( other => other.edges.some( otherEdge => 
        edge.x1 == otherEdge.x2 && edge.y1 == otherEdge.y2 &&
        edge.x2 == otherEdge.x1 && edge.y2 == otherEdge.y1
      ) )
    );
  }

    // level.cells.forEach( cell => {
    //   cell.edges = cell.edges.map( points => new Line( ...points ) );
    //   cell.links = cell.links.map( index => level.cells[ index ] ) 
    // } );

  // for ( let cellIndex = 0; cellIndex < cells.length; cellIndex ++ ) {
  //   const cell = cells[ cellIndex ];

  //   // D3 polygon has same first and last point
  //   const polygon = voronoi.cellPolygon( cellIndex );
  //   // for ( let i = polygon.length - 1; i > 0; i -- ) {
  //   //   const current = polygon[ i ], next = polygon[ i - 1 ];
  //   //   cell.edges.push( new Line( current[ 0 ], current[ 1 ], next[ 0 ], next[ 1 ] ) );
  //   // }

  //   // for ( const neighborIndex of voronoi.neighbors( 0 ) ) {
  //   //   cell.links.push( cells[ neighborIndex ] );
  //   // }

  //   cell.updateCenter();

  //   cells.push( cell );
  // }

  const ctx = document.getElementById( 'canvas' ).getContext( '2d' );
  
  voronoi.render( ctx );
  ctx.strokeStyle = 'gray';
  ctx.stroke();

  cells[ 0 ].drawDebug( ctx );
  // cells.forEach( cell => cell.drawDebug( ctx ) );

  // const colors = [ 'red', 'orange', 'yellow', 'green', 'blue', 'purple', 'brown', 'pink' ];
  // let colorIndex = 0;

  // for ( const neighborIndex of voronoi.neighbors( 0 ) ) {
  //   ctx.beginPath();
  //   voronoi.cellPolygon( neighborIndex ).forEach( point => 
  //     ctx.lineTo( point[ 0 ], point[ 1 ] ) 
  //   );
  //   ctx.fillStyle = colors[ colorIndex ++ ];
  //   ctx.fill();
  // }

  // ctx.beginPath();
  // voronoi.cellPolygon( 0 ).forEach( point => ctx.lineTo( point[ 0 ], point[ 1 ] ) );
  // ctx.fillStyle = 'white';
  // ctx.fill();
  
  // colorIndex = 0;
  // voronoi.cellPolygon( 0 ).forEach( point => {
  //   ctx.fillStyle = colors[ colorIndex ++ ];
  //   ctx.fillRect( point[ 0 ] - 3, point[ 1 ] - 3, 6, 6 );
  // } );


  // TODO: Cell under mouse?
  // Create our cells from their cells, then figure out linkages?
  
</script>