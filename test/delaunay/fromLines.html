<title>Delaunay Trianglization with holes</title>
<link rel="stylesheet" href="../../style.css">

<canvas id="canvas" width="800px" height="800px"></canvas>

<script type="module">
  import { Line } from '../../src/Line.js';
  import Delaunay from '../../lib/delaunay/delaunay.js';

  const lines = [
    // outer
    [ 100, 100,  50, 200 ],
    [  50, 200,  50, 300 ],
    [  50, 300, 100, 400 ],
    [ 100, 400, 200, 450 ],
    [ 200, 450, 300, 450 ],
    [ 300, 450, 400, 400 ],
    [ 400, 400, 450, 300 ],
    [ 450, 300, 450, 200 ],
    [ 450, 200, 400, 100 ],
    [ 400, 100, 300,  50 ],
    [ 300,  50, 200,  50 ],
    [ 200,  50, 100, 100 ],

    // inner
    [ 200, 250, 200, 125 ],
    [ 200, 125, 250, 200 ],
    [ 250, 200, 300, 125 ],
    [ 300, 125, 300, 250 ],
    [ 300, 250, 300, 275 ],
    [ 300, 275, 250, 300 ],
    [ 250, 300, 200, 275 ],
    [ 200, 275, 200, 250 ],

    // small
    [ 350, 350, 360, 350 ],
    [ 360, 350, 360, 360 ],
    [ 360, 360, 350, 360 ],
    [ 350, 360, 350, 350 ],
  ].map( e => new Line( ...e ) );

  const ctx = document.getElementById( 'canvas' ).getContext( '2d' );

  const delaunay = Delaunay.from( lines, e => e.x1, e => e.y1 );

  // TODO: Move fromEdges code to test for now, so we can instrument with more visual debug output
  // Namely, drawText the angle difference for each edge and color it based on angle (w/hue)

  // // cellMap.cells[ 0 ].drawDebug( ctx );
  // cellMap.cells.forEach( cell => cell.drawDebug( ctx ) );

  // delaunay.render( ctx );
  // ctx.strokeStyle = 'gray';
  // ctx.stroke();
  
  ctx.strokeStyle = 'white';
  lines.forEach( line => line.draw( ctx ) );

  const numTriangles = delaunay.triangles.length / 3;
  
  ctx.lineWidth = 2;

  for ( let triIndex = 6; triIndex < 7; triIndex ++ ) {

    const [ a, b, c ] = [ 0, 1, 2 ].map( i => lines[ delaunay.triangles[ triIndex * 3 + i ] ] );
    const linePairs = [ [ a, b ], [ b, c ], [ c, a ] ];
    const lineColors = [ 'red', 'green', 'blue' ];
    const pointColors = [ 'pink', 'lime', 'cyan' ];

    ctx.beginPath();
    linePairs.forEach( pair => ctx.lineTo( pair[0].x1, pair[0].y1 ) );
    ctx.closePath();

    const THRESHOLD = 0.001;
    const hole = linePairs.some( pair => {
      const [ start, end ] = pair;
      const startOverlap = ( end.x1 - start.x1 ) * start.normal.x + ( end.y1 - start.y1 ) * start.normal.y;
      const endOverlap   = ( start.x1 - end.x1 ) * end.normal.x   + ( start.y1 - end.y1 ) * end.normal.y;
      return startOverlap < -THRESHOLD && endOverlap < -THRESHOLD;
    } );

    ctx.fillStyle = hole ? 'orange' : 'yellow';
    ctx.fill();
    

    for ( let i = 0; i < 3; i ++ ) {
      const [ start, end ] = linePairs[ i ];

      // ctx.beginPath();
      // ctx.moveTo( start.x1, start.y1 );
      // ctx.lineTo( end.x1, end.y1 );
      // ctx.strokeStyle = lineColors[ i ];
      // ctx.stroke();

      const startOverlap = ( end.x1 - start.x1 ) * start.normal.x + ( end.y1 - start.y1 ) * start.normal.y; 
      const endOverlap   = ( start.x1 - end.x1 ) * end.normal.x   + ( start.y1 - end.y1 ) * end.normal.y; 

      const str = `${ startOverlap.toFixed() }, ${ endOverlap.toFixed() }`;

      ctx.fillStyle = pointColors[ i ];
      ctx.fillText( str, ( start.x1 + end.x1 ) / 2, ( start.y1 + end.y1 ) / 2 );
    }

    for ( let i = 0; i < 3; i ++ ) {
      const point = linePairs[ i ][ 0 ];

      ctx.strokeStyle = lineColors[ i ];
      point.draw( ctx );

      ctx.fillStyle = pointColors[ i ];
      ctx.fillRect( point.x1 - 3, point.y1 - 3, 6, 6 );
    }

    // 

  }

  function fixAngle( a ) {
    return a > Math.PI ? a - Math.PI * 2 : a < -Math.PI ? a + Math.PI * 2 : a;
  }

  function deltaAngle( a, b ) {
    return fixAngle( b - a );
  }

  
</script>