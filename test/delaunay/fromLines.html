<title>Delaunay Trianglization with holes</title>
<link rel="stylesheet" href="../../style.css">

<canvas id="canvas" width="800px" height="800px"></canvas>

<script type="module">
  import { Line } from '../../src/Line.js';
  import Delaunay from '../../lib/delaunay/delaunay.js';

  import { Cell, CellMap } from '../../src/CellMap.js';

  const lines = [
    // outer
    [ 100, 100,  50, 200 ],
    [  50, 200,  50, 300 ],
    [  50, 300, 100, 400 ],
    [ 100, 400, 200, 450 ],
    [ 200, 450, 300, 450 ],
    [ 300, 450, 400, 400 ],
    [ 400, 400, 450, 300 ],
    [ 450, 300, 450, 200 ],
    [ 450, 200, 400, 100 ],
    [ 400, 100, 300,  50 ],
    [ 300,  50, 200,  50 ],
    [ 200,  50, 100, 100 ],

    // inner
    [ 200, 250, 200, 125 ],
    [ 200, 125, 250, 200 ],
    [ 250, 200, 300, 125 ],
    [ 300, 125, 300, 250 ],
    [ 300, 250, 300, 275 ],
    [ 300, 275, 250, 300 ],
    [ 250, 300, 200, 275 ],
    [ 200, 275, 200, 250 ],

    // small
    [ 320, 320, 360, 320 ],
    [ 360, 320, 360, 360 ],
    [ 360, 360, 320, 360 ],
    [ 320, 360, 320, 320 ],


    // [ 100, 300, 200, 320 ],
    // [ 200, 320, 210, 400 ],
    // [ 250, 100,  50, 150 ],

  ].map( e => new Line( ...e ) );

  const ctx = document.getElementById( 'canvas' ).getContext( '2d' );

  
  // // cellMap.cells[ 0 ].drawDebug( ctx );
  // cellMap.cells.forEach( cell => cell.drawDebug( ctx ) );
  
  ctx.strokeStyle = 'white';
  lines.forEach( line => line.draw( ctx ) );

  // const pathMap = CellMap.fromEdges( lines );
  // pathMap.drawDebug( ctx );

  const delaunay = Delaunay.from( lines, e => e.x1, e => e.y1 );
  delaunay.render( ctx );
  ctx.strokeStyle = 'gray';
  ctx.stroke();

  const cellMap = new CellMap();

  const numTriangles = delaunay.triangles.length / 3;

  const cells = Array( numTriangles ).fill( null );

  for ( let triIndex = 0; triIndex < numTriangles; triIndex ++ ) {
    const [ a, b, c ] = [ 0, 1, 2 ].map( i => lines[ delaunay.triangles[ triIndex * 3 + i ] ] );
    const linePairs = [ [ a, b ], [ b, c ], [ c, a ] ];

    const center = {
      x: ( a.x1 + b.x1 + c.x1 ) / 3,
      y: ( a.y1 + b.y1 + c.y1 ) / 3,
    };

    ctx.fillStyle = 'red';
    ctx.fillRect( center.x - 2, center.y - 2, 4, 4 );


    const cell = new Cell();
    cell.edges.push( new Line( a.x1, a.y1, b.x1, b.y1 ) );
    cell.edges.push( new Line( b.x1, b.y1, c.x1, c.y1 ) );
    cell.edges.push( new Line( c.x1, c.y1, a.x1, a.y1 ) );
    cell.updateCenter();

    const inBounds = [ a, b, c ].map( e => {
      const px = e.x2 - e.x1;
      const py = e.y2 - e.y1;
      const u = ( ( center.x - e.x1 ) * px + ( center.y - e.y1 ) * py ) / ( ( px * px ) + ( py * py ) );

      return 0 <= u && u <= 1;
    } );
    
    const dirs = [ a, b, c ].map( e => 
      ( center.x - e.x1 ) * e.normal.x + ( center.y - e.y1 ) * e.normal.y
    );

    // if ( dirs[ 0 ] < 0 )  cell.drawShaded( ctx, 'red' );
    // if ( dirs[ 1 ] < 0 )  cell.drawShaded( ctx, 'green' );
    // if ( dirs[ 2 ] < 0 )  cell.drawShaded( ctx, 'blue' );

    const hole = dirs.filter( e => e < 0 ).length > 1;

    cell.drawShaded( ctx, hole ? 'red' : 'green' );

    // if (
    //   linePairs.some( pair => {
    //     const [ start, end ] = pair;
    //     if ( ( end.x1 - start.x1 ) * start.normal.x + ( end.y1 - start.y1 ) * start.normal.y > 0 ) {
    //       const px = start.x2 - start.x1;
    //       const py = start.y2 - start.y1;
    //       const u = ( ( end.x1 - start.x1 ) * px + ( end.y1 - start.y1 ) * py ) / ( ( px * px ) + ( py * py ) );

    //       return 0 <= u && u <= 1
    //     }

    //     return false;
    //   }

    //   )
    // )   cell.drawShaded( ctx, 'green' );
    
    // if ( a.x1 == b.x2 && a.y1 == b.y2 || 
    //      b.x1 == c.x2 && b.y1 == c.y2 ||
    //      c.x1 == a.x2 && c.y1 == a.y2 ) {
    //   cell.drawShaded( ctx, 'red' );
    // }
    // else if ( hole ) {
    //   cell.drawShaded( ctx, 'orange' );
    // }
    // else {
    //   cell.drawShaded( ctx, 'green' );
    // }
  }
    

  //   for ( let i = 0; i < 3; i ++ ) {
  //     const [ start, end ] = linePairs[ i ];

  //     // ctx.beginPath();
  //     // ctx.moveTo( start.x1, start.y1 );
  //     // ctx.lineTo( end.x1, end.y1 );
  //     // ctx.strokeStyle = lineColors[ i ];
  //     // ctx.stroke();

  //     const startOverlap = ( end.x1 - start.x1 ) * start.normal.x + ( end.y1 - start.y1 ) * start.normal.y; 
  //     const endOverlap   = ( start.x1 - end.x1 ) * end.normal.x   + ( start.y1 - end.y1 ) * end.normal.y; 

  //     const str = `${ startOverlap.toFixed() }, ${ endOverlap.toFixed() }`;

  //     ctx.fillStyle = pointColors[ i ];
  //     ctx.fillText( str, ( start.x1 + end.x1 ) / 2, ( start.y1 + end.y1 ) / 2 );
  //   }

  //   for ( let i = 0; i < 3; i ++ ) {
  //     const point = linePairs[ i ][ 0 ];

  //     ctx.strokeStyle = lineColors[ i ];
  //     point.draw( ctx );

  //     ctx.fillStyle = pointColors[ i ];
  //     ctx.fillRect( point.x1 - 3, point.y1 - 3, 6, 6 );
  //   }

  //   // 

  // }


  // function fixAngle( a ) {
  //   return a > Math.PI ? a - Math.PI * 2 : a < -Math.PI ? a + Math.PI * 2 : a;
  // }

  // function deltaAngle( a, b ) {
  //   return fixAngle( b - a );
  // }

  
</script>