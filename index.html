<title>Tunnels</title>
<link rel="stylesheet" href="./style.css">

<body>
  <div id="layers"></div>
  <div id="remaining"><span id="numLeft"></span> enemies left</div>
  <div class="center" id="victory">Level Clear</div>
</body>

<script type="module">
  import { GameUpdate } from './src/GameUpdate.js';
  import { World } from './src/World.js';
  import { Wall } from './src/Wall.js';
  import { AvoidingActor } from './src/AvoidingActor.js';

  import { ActorInfo } from './info/info.js';
  
  
  const groundLayer = createLayer( 1000, 1000 );
  const actorsLayer = createLayer( 1000, 1000 );

  const layersDiv = document.getElementById( 'layers' );
  layersDiv.appendChild( groundLayer.canvas );
  layersDiv.appendChild( actorsLayer.canvas );

  const ui = Object.fromEntries( [ 'numLeft', 'victory' ].map( e => [ e, document.getElementById( e ) ] ) );

  let levelIndex = 0;
  const levels = [
    './levels/test6.json',
    './levels/test7.json',
  ];

  let world;

  const gameUpdate = new GameUpdate( ( dt ) => {
    world.update( dt );

    const numEnemies = world.entities.filter( e => e.info.type == 'alien' ).length;
    ui.numLeft.innerText = numEnemies;

    if ( numEnemies == 0 ) {
      ui.victory.style.visibility = 'visible';
    }

    drawActors();
  } );

  function drawGround() {
    const ctx = groundLayer;
    ctx.clearRect( 0, 0, ctx.canvas.width, ctx.canvas.height );
    const walls = world.entities.filter( e => e.info.type == 'wall' );
    walls.forEach( wall => wall.draw( ctx ) );
  }

  function drawActors() {
    const ctx = actorsLayer;
    ctx.clearRect( 0, 0, ctx.canvas.width, ctx.canvas.height );
    
    const marines = world.entities.filter( e => e.info.type == 'marine' );
    marines.forEach( marine => {
      marine.drawUI( ctx );

      if ( marine.moveTarget ) {
        ctx.beginPath();
        ctx.moveTo( marine.moveTarget.x, marine.moveTarget.y );
        ctx.lineTo( marine.x, marine.y );
        ctx.strokeStyle = 'cyan';
        ctx.setLineDash( [ 5, 5 ] );
        ctx.stroke();
        ctx.setLineDash( [] );
      }
    } );

    world.entities.filter( e => e.info.type != 'wall' ).forEach( e => e.draw( actorsLayer ) );

    marines.forEach( marine => marine.drawUI( actorsLayer ) );
  }

  loadLevel( levels[ 0 ] );

  async function loadLevel( path ) {
    gameUpdate.stop();
    world = await World.fromFile( path );
    drawGround();
    gameUpdate.start();
  }

  function prevLevel() {
    levelIndex = Math.max( 0, levelIndex - 1 );
    loadLevel( levels[ levelIndex ] );
  }
  
  function nextLevel() {
    levelIndex = Math.min( levels.length - 1, levelIndex + 1 );
    loadLevel( levels[ levelIndex ] );
  }

  document.addEventListener( 'keydown', ( e ) => {
    switch( e.code ) {
      case 'KeyN':  nextLevel();  break;
      case 'KeyP':  prevLevel();  break;
    }
  } );

  document.addEventListener( 'mousedown', ( e ) => {
    const moveTarget = { x: e.offsetX, y: e.offsetY };

    const marines = world.entities.filter( e => e.info.type == 'marine' );

    const center = { x: 0, y: 0 };

    marines.forEach( marine => {
      center.x += marine.x;
      center.y += marine.y;
    } );

    center.x /= marines.length;
    center.y /= marines.length;

    const moveAngle = Math.atan2( moveTarget.y - center.y, moveTarget.x - center.x );

    const offsets = marines.map( marine => ( {
      marine: marine,
      offset: ( marine.x - moveTarget.x ) * Math.sin( moveAngle ) + ( marine.y - moveTarget.y ) * -Math.cos( moveAngle )
    } ) ).sort( ( a, b ) => a.offset - b.offset );

    const SPACING = ActorInfo.marine.size * 2.5;
    const adjust = 0.5 * ( offsets.length - 1 );

    offsets.forEach( ( e, index ) => e.marine.moveTarget = { 
      x: moveTarget.x + ( index - adjust ) * SPACING * Math.sin( moveAngle ),
      y: moveTarget.y + ( index - adjust ) * SPACING * -Math.cos( moveAngle ),
    } );
  } );

  function createLayer( width, height ) {
    const canvas = document.createElement( 'canvas' );
    
    canvas.width = width * devicePixelRatio;
    canvas.height = height * devicePixelRatio;
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';

    const ctx = canvas.getContext( '2d' );
    ctx.scale( devicePixelRatio, devicePixelRatio );

    return ctx;
  }

</script>